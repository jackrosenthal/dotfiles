#!/usr/bin/env python3
# Copyright 2019 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import io
import os
import pathlib
import re
import requests
import sched
import site
import subprocess
import tempfile
import textwrap
import time

site.addsitedir(pathlib.Path(os.getenv('HOME')) / 'chromiumos')

import chromite.lib.gob_util as gob_util
from chromite.lib.patch import PatchQuery, GerritPatch, GetPaladinDeps
from chromite.lib.gerrit import GerritHelper

scheduler = sched.scheduler(time.time, time.sleep)

BOT_DISCLAIMER_MESSAGE = (
    'This is an automated message from a bot trying to be '
    "helpful.  If I'm mis-behaving, or if this message seems "
    'to be wrong, please feel free to reach out to my owner, '
    'jrosenth@chromium.org.')


class GerritInstance(GerritHelper):
  def Query(self, *args, **kwargs):
    results = super().Query(*args, bypass_cache=False, **kwargs)
    for r in results:
      r.instance = self
    return results


instances = {
    'chromium': GerritInstance.FromGob('chromium'),
    'chrome-internal': GerritInstance.FromGob('chrome-internal'),
}
_instances = {i.remote: i for i in instances.values()}


def instance_from_remote(remote):
  if remote not in _instances.keys():
    _instances[remote] = GerritInstance.FromRemote(remote)
  return _instances[remote]


class PatchError(Exception):
  pass


mark_ready_banned = set()


def ban_mark_ready(patch, seconds):
  mark_ready_banned.add(patch.url)

  def make_available():
    print(patch.url, "is available to be marked CQ+2 again!")
    mark_ready_banned.remove(patch.url)

  scheduler.enter(seconds, 0, make_available)

def patch_mark_ready_error(patch):
  if patch.IsDraft():
    return 'is a draft.'
  if patch.IsPrivate():
    return 'is private.'
  if patch.status == 'ABANDONED':
    return 'was abandoned.'
  if patch.HasApproval('VRIF', '-1'):
    return 'is marked Verified=-1.'
  if patch.HasApproval('CRVW', '-2'):
    return 'is marked Code-Review=-2.'
  if not patch.HasApproval('CRVW', '2'):
    return 'is not marked Code-Review=+2.'
  if not patch.HasApproval('VRIF', '1'):
    return 'is not marked Verified=+1.'
  if not patch.HasApproval('COMR', '2') and patch.url in mark_ready_banned:
    return 'was marked ready too recently and is not currently CQ+2'
  return None


def mark_ready(patch):
  err = patch_mark_ready_error(patch)
  if err:
    raise PatchError('{} {}'.format(patch.url, err))
  if patch.status != 'NEW':
    raise PatchError('{} is already submitted or merged.'.format(patch.url))
  if patch.HasApproval('COMR', '2'):
    print('{} is already marked CQ+2.'.format(patch.url))
    return
  print('Marking {} CQ+2...'.format(patch.url))
  patch.instance.SetReview(patch, labels={'Commit-Queue': '+2'}, notify='OWNER')
  patch.instance.SetHashtags(patch, add=[], remove=['cq1'])
  ban_mark_ready(patch, 60 * 30)


def _needed_deps(patch, visited):
  if not isinstance(patch, GerritPatch):
    instance = instance_from_remote(patch.remote)
    for patch in instance.Query(patch.ToGerritQueryText()):
      yield from _needed_deps(patch, visited)
    return
  if patch.status in ('MERGED', 'SUBMITTED'):
    return
  if patch.url in visited:
    return
  err = patch_mark_ready_error(patch)
  if err:
    raise PatchError('{} {}'.format(patch.url, err))
  visited.add(patch.url)
  yield patch
  for child in patch.GerritDependencies():
    yield from _needed_deps(child, visited)
  for child in GetPaladinDeps(patch._commit_message):
    yield from _needed_deps(child, visited)


def needed_deps(patch):
  visited = set()
  yield from _needed_deps(patch, visited)


def query_and_mark_ready(instance, qs):
  cls = list(instance.Query(qs))
  if cls:
    print(' {} CLs to process'.format(len(cls)))
  else:
    print(' nothing to do!')
  for cl in cls:
    try:
      deps = list(needed_deps(cl))
    except PatchError as e:
      print('Either {} or its dependencies are not ready yet. '
            '({})'.format(cl.url, e))
    else:
      for dep in deps:
        mark_ready(dep)


#def sticky_cq_task():
#  for name, instance in instances.items():
#    print("Querying {}...".format(name), end='')
#    query_and_mark_ready(instance, 'hashtag:stickycq status:open')
#  scheduler.enter(90, 10, sticky_cq_task)


def cq1_task():
  for name, instance in instances.items():
    print("Querying CQ1 for {}...".format(name), end='')
    query_and_mark_ready(instance, 'hashtag:cq1 status:open')
  scheduler.enter(90, 10, cq1_task)


auto_cc_searches = [
    'mosys after:2020-03-09',
    'CrosConfig after:2020-03-09',
]


def auto_cc_task():
  base_query = ('-status:abandoned -owner:jrosenth -author:jrosenth '
                '-owner:chromeos-ci-prod -reviewer:jrosenth -cc:jrosenth '
                '-star:ignore -is:wip')
  for name, instance in instances.items():
    for search in auto_cc_searches:
      search_query = '{} {}'.format(search, base_query)
      print("Querying AutoCC for '{}' on {}...".format(name, search_query))
      cls = list(instance.Query(search_query))
      for cl in cls:
        print("AutoCC added to {}:{}!".format(name, cl))
        cl.instance.SetReview(cl, msg="Automated CC", notify='NONE')
  scheduler.enter(120, 15, auto_cc_task)


zephyr_upstream_repos = [
    ('chromiumos/third_party/zephyr',
     'https://github.com/zephyrproject-rtos/zephyr'),
    ('chromiumos/third_party/zephyr/cmsis',
     'https://github.com/zephyrproject-rtos/cmsis'),
    ('chromiumos/third_party/zephyr/hal_stm32',
     'https://github.com/zephyrproject-rtos/hal_stm32'),
]

# TODO: change to -2 when this bot gets a track record
REVIEW_STRICTLY_DO_NOT_SUBMIT = '-1'
REVIEW_PREFER_NOT_SUBMITTED = '-1'
REVIEW_NEEDS_HUMAN_APPROVAL = '+1'
REVIEW_AUTOMATIC_APPROVAL = '+1'


def zephyr_upstream_task():
  instance = instances['chromium']

  for project, upstream in zephyr_upstream_repos:
    search_query = ' '.join([
        'project:{}'.format(project),
        'status:open',
        '-owner:copybara-worker-blackhole@google.com',
        '-topic:zephyr-downstream',
        '-label:Verified=-1',
    ])
    cls = list(instance.Query(search_query))
    print('zephyr_upstream_task: {} CLs to filter from {}'.format(
        len(cls), project))
    for cl in cls:
      ps_number = cl.patch_dict['currentPatchSet']['number']
      proc_hashtag = 'zephyr_upstream_bot_checked_ps{}'.format(ps_number)

      proc_query = '{} {} -hashtag:{}'.format(
          search_query, cl.ToGerritQueryText(), proc_hashtag)

      for cl_needs_proc in instance.Query(proc_query):
        def setlabels(labels, msg=None):
          print('Setting {!r} on {}...'.format(labels, cl_needs_proc.url))
          cl_needs_proc.instance.SetReview(cl_needs_proc, msg=msg,
                                           labels=labels)

        # Reset Code-Review until we decide the new review.
        # OK if Gerrit quirks out or something.
        try:
          setlabels({'Code-Review': '0'})
        except gob_util.GOBError:
          pass

        cr, message = zephyr_get_review(cl_needs_proc, upstream)

        message += '\n\n'
        message += BOT_DISCLAIMER_MESSAGE

        labels = {'Code-Review': str(cr)}
        setlabels(labels, msg=message)
        cl_needs_proc.instance.SetHashtags(cl_needs_proc,
                                           add=[proc_hashtag],
                                           remove=[])

  scheduler.enter(200, 20, zephyr_upstream_task)


def check_frompull_commit(cl, upstream_url):
  p = re.compile(re.escape('{}/pull/'.format(upstream_url)) + r'[0-9]+')
  m = p.search(cl.commit_message)
  if not m:
    return (REVIEW_STRICTLY_DO_NOT_SUBMIT,
            'Please add a link to the pull request in the commit message.')
  return (REVIEW_NEEDS_HUMAN_APPROVAL,
          'Reviewers: please identify if this FROMPULL commit is acceptable '
          'to merge to our Chromium OS branches.')


def check_chromium_commit(cl, upstream_url):
  return (REVIEW_PREFER_NOT_SUBMITTED,
          'The CHROMIUM tag is used for commits in this repository which '
          'cannot be upstreamed.\n'
          '\n'
          'Generally speaking, almost all commits can either be '
          'upstreamed, or instead landed in one of our local '
          'repositories, such as platform/ec.\n'
          '\n'
          "* If it's possible to upstream this CL, please do so.  You "
          'can reupload this CL with the FROMPULL tag instead after '
          'uploading the pull request.\n'
          '\n'
          "* Otherwise, if it's possible to land this code in "
          'platform/ec or another local repository instead, please do '
          'that, and abandon this CL.\n'
          '\n'
          'If none of the above are possible, you may remove my CR-1 on '
          'this CL and proceed with the review.\n'
          '\n'
          'Thanks for helping us keep upstream first!\n')


zephyr_tags = [
    ('FROMPULL', check_frompull_commit,
     'This tag should be used for commits which have not yet been merged '
     'into upstream Zepyhr, but have a pending pull request open.  Please '
     'link to the pull request in the commit message.'),
    ('CHROMIUM', check_chromium_commit,
     'This tag should be used for commits which will never be upstreamed. '
     'Generally speaking, these commits can almost always be avoided by '
     'landing code in one of the repositories we maintain (i.e., platform/ec), '
     "and should only be used as a last resort if it's impossible to put it in "
     "one of our modules, and upstream won't accept our change.  Please "
     'include adequate justification as to why this commit cannot be '
     'upstreamed in your commit message.'),
]

COPYBOT_MSG = (
    'Upstream commits are now automatically cherry-picked into our main branch '
    'daily by CopyBot.  There is no need to manually cherry-pick into the main '
    'branch.\n\n'
    'If you need a commit expedited into the main branch, or otherwise believe '
    'that your commit has not been copied, please contact the current '
    'downstreamer.  Googlers can see the current downstreamer by visiting '
    'https://rotations.corp.google.com/rotation/4735002850885632. '
    'Non-googlers should reach out to their contacts at Google for further '
    'assistance.'
)

zephyr_obsolete_tags = [
    ('BACKPORT', COPYBOT_MSG),
    ('UPSTREAM', COPYBOT_MSG),
]


def zephyr_get_review(cl, upstream_url):
  if 'chromeos-v' in cl.tracking_branch:
    return (
        REVIEW_STRICTLY_DO_NOT_SUBMIT,
        f'The {cl.tracking_branch} branch is now closed.  Please re-open your '
        f'CL on the main branch.'
    )
  for tag, review_func, helpmsg in zephyr_tags:
    if cl.commit_message.startswith('{}: '.format(tag)):
      return review_func(cl, upstream_url)

  for tag, helpmsg in zephyr_obsolete_tags:
    if cl.commit_message.startswith(f'{tag}: '):
      msg = (
          f"The {tag} tag is obsolete and should no longer be used.\n\n"
          f"{helpmsg}"
      )
      return REVIEW_STRICTLY_DO_NOT_SUBMIT, msg

  # No tag matched
  msg = """Your commit message subject line in this repository MUST include one
of the following tags to help us track upstream changes:

"""
  for tag, review_func, helpmsg in zephyr_tags:
    msg += '* {}: {}\n\n'.format(tag, helpmsg)

  msg += COPYBOT_MSG

  msg += (
      "Tip: Are you uploading a CL you don't intend to submit?  Upload it "
      "with the `Verified-1` label and I'll ignore your CL.  You can do this "
      "using `repo upload` by adding `-l Verified-1` to your command."
  )

  return REVIEW_STRICTLY_DO_NOT_SUBMIT, msg


GITLAB_PROJECT_ID = 23994572
GITLAB_PROJECT_URL = "https://gitlab.com/zephyr-ec/ec"


def gitlab_ci_spawner_task():
  instance = instances['chromium']

  search_query = 'project:chromiumos/platform/ec status:open'
  cls = list(instance.Query(search_query))
  print('gitlab_ci_spawner: {} CLs to possibly start CI'.format(len(cls)))
  for cl in cls:
    ps_number = cl.patch_dict['currentPatchSet']['number']
    proc_hashtag = 'zephyr_gitlab_ci_ps{}'.format(ps_number)

    proc_query = '{} {} -hashtag:{}'.format(
        search_query, cl.ToGerritQueryText(), proc_hashtag)

    for cl_needs_proc in instance.Query(proc_query):
      try:
        gitlab_ci_spawn(cl_needs_proc)
      except Exception:
        print("WRN: Unable to spawn external CI on {}".format(cl_needs_proc))
        traceback.print_exc(file=sys.stderr)
      cl_needs_proc.instance.SetHashtags(cl_needs_proc,
                                         add=[proc_hashtag],
                                         remove=[])

  scheduler.enter(200, 20, gitlab_ci_spawner_task)


def gitlab_ci_spawn(cl):
  pass


HEALTHCHECK_URL = "https://hc-ping.com/be605a09-bdec-463a-b359-40062a4d41dc"


def healthcheck():
  r = requests.get(HEALTHCHECK_URL)
  scheduler.enter(10 * 60, 30, healthcheck)


def main():
  scheduler.enter(0, 10, cq1_task)
  scheduler.enter(5, 15, auto_cc_task)
  scheduler.enter(10, 20, zephyr_upstream_task)
  scheduler.enter(0, 30, healthcheck)
  try:
    scheduler.run()
  except Exception as e:
    r = requests.get(HEALTHCHECK_URL + "/fail", data=str(e))
    raise e


if __name__ == '__main__':
  main()
